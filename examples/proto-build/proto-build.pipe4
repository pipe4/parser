// схема в соответствии с которой парсится этот язык
// на случай если в дальнейшем будут несовместимые изменения или какие-то раширения которых нет в базовой версии
parser "github.com/pegilang/scheme/v1"

// импорт зависимостей, они могут быть как паплайнами,
//  либо какими-то блоками,
//  либо низкоуровневыми реализациями общих вещей под разные языки,
//  либо конкретные функции на конкретных языках
import (
  // некий базовый функционал примитивов такие как stream/message/fs реализация которых есть под разные языки
  "github.com/pegilang/core"
  // модуль для подписывания на изменения в git репозитории, вероятно это будет пайплайн из более примитивных блоков
  "github.com/pegipkg/git-subscribe"
  // модуль для пула git репозитория в временную папку
  "github.com/pegipkg/git-pull"
  // модуль который позволяет выполнить какую-то linux комманду на базе какой-то os
  "github.com/pegipkg/linux-tool"
  // модуль для пуша локальных изменений в git репозиторий
  "github.com/pegipkg/git-push"
  // функция регулярных выражений, вероятно реализация будет на разные языки своя
  "github.com/pegipkg/regexp"
)

// описывает интерфейс параметров к этому пайплайну
interface PipelineProps {
	from core.url
	to   core.url
	lang core.string
}

// резолвит параметры на вход пайплайну и сохраняет в переменную
pipelineProps, badProps := core.Pipeline.Props(PipelineProps)

/*
  этот файл описывает некую схему как летят данные через разные обработчики
  на выходе он скомпилируется в ast представление которое может обработать движок который запускает пайплайны
  функции которые используются преобразуются на основе ast в сгенеренный код и в действия которые необходимо будет выполнить движку.
  например если мы слушаем эвенты которые генерит какой-то сервис, то будет скопилирован этот сервис,
	функция которая слушает эфенты будет запущена на постоянной основе с помощью враппера который будет скодогенерирован
	на разных языках своим образом в зависимости от языка на котором написана функция будет способ получения событий из этого сервиса
	например для go это может быть go chan, для java просто supplier на вход параметром к сервису.
	когда враппер получит очередное сообщение он отправит его в общую очередь сообщений
	тип сообщения будет сгенерен на основе имени файла пайплайна и имени модуля который используется для генерации событий
	на каждый тип сообщения будет создан топик в базе сообщений и сами сообщения будут помечены тэгами которые зависят от реального окружения
	 чтобы можно было в дальнейшем фильтровать события
	враппер попытается сразу вызвать функцию обработчик которая стоит следующим блоком в пайплайне для ускорения обработки
	 если эта функция доступна на этом же языке то скорее всего она будет скопилина в том же бинарнике и вызов будет мгновенно просто вызовом функции
	 если на другом языке то движок запуска всего этого дела постарается запустить сервис на той же машине если есть доступные ресурсы
*/

/*
	спавн некого сервиса листенера, который слушает изменения в текущем репозитории по относительному пути от этого файла
	на выходе у него поток событий на каждое изменение который потом можно как-то обработать
	если не получилось прослушать репозиторий, например потому что он не существует, то есть объект ошибки,
		который можно как-то обработать и отправить куда-то помимо дефолтного поведения показа ошибок в ui

	core.stream описывает поток эвентов которые могут например лечь в базу данных типа kafka
	core.message описывает нечто что можно сериализовать в json
	core.error общий интерфейс ошибок
*/
git-subscibe()
gitChangeNotifications, gitSubscribeErr := git-subscibe({
	// подписываемся по относительному пути, в данном случае это будет git@github.com:pegilang/example.git@main /pipeline/proto
	url: pipelineProps.from,
	// событие будет только если изменились файлы этого типа
	match: regexp(`.proto$`),
})

/*
  обрабатываем каждое сообщение в стриме эвентов, сохраняем некий указатель чтобы ссылаться на одно и тоже сообщение в разных обработчиках
  стрим пайпланится в метод который извлекает сообщения по одному и передает их дальше по цепочке
  если не удалось подписаться на события то выше будет ошибка, а подпись будет только когда сам стрим не null, то есть если ошибки не было

  core.stream.unit врапит объект, помечая его неким контекстом обработки в рамках общего стрима
				   это нужно например чтобы в дальнейшем можно было отличить message как объект и message которые являются единицей обработки стрима
*/
gitChangeNotification :=
	| gitChangeNotifications
	| core.stream.each(gitChangeNotifications)

/*
  на каждый notification который получили запускаем git pull с параметрами из этого notification
  на выходе у нас папка с файлами которая создается во временной папке внутри контейнера обработки
   или ошибка если не получилось запулить
*/
protoDir, pullErr :=
	| gitChangeNotification
	| git-pull({
		url: gitChangeNotification.url,
	})

// временная папка куда будем билдить
outDir  := core.fs.tmp()

// после того как скачалась папка с proto файлами и создалась tmp папка запускаем команду внутри контейнера
buildInfo, buildErr :=
	| protoDir, outDir
	| linux-tool({
		// название image из докер репозитория, в данном случае arch linux
		image: "arch",
		// какие пакеты надо поставить через пакетный менеджер
		install: ["protobuf"],
		// переменные окружения которые пробрасываются внутрь контейнера
		env: {
			  PROTO_DIR: core.fs.path(protoDir),
			  OUT_DIR: core.fs.path(outDir),
			  LANG: pipelineProps.lang,
		},
		// protoDir монтируется внутрь контейнера и делается ставится как директория при входе в контейнер
		workdir: protoDir,
		// запускается bash shell
		run: "/bin/bash -c",
		// input на вход в bash shell
		//input: <<EOF
		//	protoc --$LANG_out $OUT_DIR `find $PROTO_DIR | grep .proto$`
		//EOF,
	})

// после того как успешно сбилжены proto файлы (только в этом случае вернется buildInfo) пушим файлы в куда указано в параметрах
pushInfo, pushErr :=
	| buildInfo, outDir
	| git-push({
		// url куда пушить, git repo, branch, path
		to: pipelineProps.to,
		from: outDir,
		// удалить все файлы которые есть в данный момент в целевой папке
		clean: true,
	})


// объект на выход стрима с информацией о результате компиляции
compileInfo :=
   | gitChangeNotification, pushInfo, buildInfo
   // собираем всю доступную инфу из предыдущих шагов
   | core.message({
	   gitChangeNotification,
	   pushInfo,
	   buildInfo,
	})

// ошибки компиляции на выход стрима
compileError :=
	| pullErr, buildErr, pushErr
	// объединяем ошибки в одну
	| core.error.join(pullErr, buildErr, pushErr)

// преобразуем конкретные сообщения в общий стрим всей обработки
// когда из этого стрима будем потом вызывать each будет возвращаться тупл с сообщением и ошибкой
// например мы можем собрать все ошибки и попробовать сделать что-то еще раз
compileStream := core.stream.from(compileInfo, compileError)

// возвращаем стрим обработки и ошибку если не получилось запустить обработку
// то что передаем в return вернется как результат вызова этого пайплайна
core.Pipeline.Return(compileStream, core.error.join(badProps, gitSubscribeErr))